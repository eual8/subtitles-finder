<?php

namespace App\Console\Commands;

use App\Models\Fragment;
use Illuminate\Console\Command;
use Illuminate\Support\Arr;
use Throwable;
use Typesense\Client;
use Typesense\Exceptions\ObjectNotFound;

class TypesenseImportFragments extends Command
{
    private const string COLLECTION_NAME = 'fragments';

    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'typesense:import-fragments {--chunk=500 : Number of fragments to push per batch}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Sync the fragments table into the Typesense fragments collection (skipping vector data).';

    public function handle(): int
    {
        $client = $this->makeClient();

        if (! $client) {
            return self::FAILURE;
        }

        if (! $this->collectionExists($client, self::COLLECTION_NAME)) {
            $this->error('Typesense collection "'.self::COLLECTION_NAME.'" not found. Run php artisan typesense:create-index first.');

            return self::FAILURE;
        }

        $chunkSize = (int) $this->option('chunk');

        if ($chunkSize <= 0) {
            $this->error('Chunk size must be a positive integer.');

            return self::FAILURE;
        }

        $total = Fragment::count();

        if ($total === 0) {
            $this->info('No fragments found to import.');

            return self::SUCCESS;
        }

        $progressBar = $this->output->createProgressBar($total);
        $progressBar->start();

        try {
            Fragment::query()
                ->orderBy('id')
                ->chunkById($chunkSize, function ($fragments) use ($client, $progressBar) {
                    $documents = $fragments->map(fn (Fragment $fragment) => $this->fragmentToDocument($fragment))->all();

                    $client->collections[self::COLLECTION_NAME]
                        ->documents
                        ->import($documents, ['action' => 'upsert']);

                    $progressBar->advance(count($documents));
                });
        } catch (Throwable $exception) {
            report($exception);
            $this->newLine();
            $this->error('Failed to import fragments into Typesense: '.$exception->getMessage());

            return self::FAILURE;
        }

        $progressBar->finish();
        $this->newLine(2);

        $this->info(sprintf('Imported %d fragments into Typesense.', $total));

        return self::SUCCESS;
    }

    private function fragmentToDocument(Fragment $fragment): array
    {
        return [
            'id' => (int) $fragment->id,
            'video_id' => (int) $fragment->video_id,
            'text' => (string) $fragment->text,
            'time_string' => $fragment->time_string,
            'is_autogenerated' => (bool) $fragment->is_autogenerated,
            'created_at' => optional($fragment->created_at)?->getTimestamp(),
            'updated_at' => optional($fragment->updated_at)?->getTimestamp(),
        ];
    }

    private function makeClient(): ?Client
    {
        $config = config('typesense');

        if (empty($config['api_key'])) {
            $this->error('TYPESENSE_API_KEY is not configured.');

            return null;
        }

        if (empty($config['nodes'])) {
            $this->error('Typesense nodes are not configured (see config/typesense.php).');

            return null;
        }

        return new Client([
            'api_key' => $config['api_key'],
            'nodes' => $config['nodes'],
            'connection_timeout_seconds' => Arr::get($config, 'connection_timeout_seconds', 2),
        ]);
    }

    private function collectionExists(Client $client, string $collectionName): bool
    {
        try {
            $client->collections[$collectionName]->retrieve();

            return true;
        } catch (ObjectNotFound) {
            return false;
        }
    }
}
