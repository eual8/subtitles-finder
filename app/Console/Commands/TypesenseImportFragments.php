<?php

namespace App\Console\Commands;

use App\Models\Fragment;
use Illuminate\Console\Command;
use Illuminate\Support\Arr;
use Illuminate\Support\Collection;
use Illuminate\Support\Facades\Http;
use RuntimeException;
use Throwable;
use Typesense\Client;
use Typesense\Exceptions\ObjectNotFound;

class TypesenseImportFragments extends Command
{
    private const string COLLECTION_NAME = 'fragments';

    private const int EMBEDDING_BATCH_LIMIT = 100;

    /**
     * The name and signature of the console command.
     *
     * @var string
     */
    protected $signature = 'typesense:import-fragments {--chunk=500 : Number of fragments to push per batch}';

    /**
     * The console command description.
     *
     * @var string
     */
    protected $description = 'Sync the fragments table into the Typesense fragments collection, generating text embeddings en route.';

    public function handle(): int
    {
        $client = $this->makeClient();

        if (! $client) {
            return self::FAILURE;
        }

        if (! $this->collectionExists($client, self::COLLECTION_NAME)) {
            $this->error('Typesense collection "'.self::COLLECTION_NAME.'" not found. Run php artisan typesense:create-index first.');

            return self::FAILURE;
        }

        $chunkSize = (int) $this->option('chunk');

        if ($chunkSize <= 0) {
            $this->error('Chunk size must be a positive integer.');

            return self::FAILURE;
        }

        $total = Fragment::count();

        if ($total === 0) {
            $this->info('No fragments found to import.');

            return self::SUCCESS;
        }

        $progressBar = $this->output->createProgressBar($total);
        $progressBar->start();

        try {
            Fragment::query()
                ->orderBy('id')
                ->chunkById($chunkSize, function ($fragments) use ($client, $progressBar) {
                    $documents = $this->buildDocumentsWithEmbeddings($fragments);

                    $client->collections[self::COLLECTION_NAME]
                        ->documents
                        ->import($documents, ['action' => 'upsert']);

                    $progressBar->advance(count($documents));
                });
        } catch (Throwable $exception) {
            report($exception);
            $this->newLine();
            $this->error('Failed to import fragments into Typesense: '.$exception->getMessage());

            return self::FAILURE;
        }

        $progressBar->finish();
        $this->newLine(2);

        $this->info(sprintf('Imported %d fragments into Typesense.', $total));

        return self::SUCCESS;
    }

    private function buildDocumentsWithEmbeddings(Collection $fragments): array
    {
        $embeddings = $this->fetchEmbeddings($fragments);

        return $fragments->map(function (Fragment $fragment) use ($embeddings) {
            $vector = $embeddings[$fragment->id] ?? null;

            return $this->fragmentToDocument($fragment, $vector);
        })->all();
    }

    private function fragmentToDocument(Fragment $fragment, ?array $embedding = null): array
    {
        $document = [
            'id' => (int) $fragment->id,
            'video_id' => (int) $fragment->video_id,
            'text' => (string) $fragment->text,
            'time_string' => $fragment->time_string,
            'is_autogenerated' => (bool) $fragment->is_autogenerated,
            'created_at' => optional($fragment->created_at)?->getTimestamp(),
            'updated_at' => optional($fragment->updated_at)?->getTimestamp(),
        ];

        if ($embedding !== null) {
            $document['text_vector'] = $embedding;
        }

        return $document;
    }

    private function fetchEmbeddings(Collection $fragments): array
    {
        if ($fragments->isEmpty()) {
            return [];
        }

        $url = env('SENTENCE_EMBEDDINGS_URL');
        $textsById = $fragments
            ->mapWithKeys(fn (Fragment $fragment) => [$fragment->id => $fragment->text])
            ->all();

        $vectors = [];

        foreach (array_chunk($textsById, self::EMBEDDING_BATCH_LIMIT, true) as $batch) {
            $response = Http::timeout(30)->post($url, [
                'texts' => array_values($batch),
                'normalize' => true,
            ]);

            if ($response->failed()) {
                throw new RuntimeException(sprintf(
                    'Sentence embeddings request failed with status %d.',
                    $response->status()
                ));
            }

            $body = $response->json();
            $embeddings = $body['embeddings'] ?? null;

            if (! is_array($embeddings) || count($embeddings) !== count($batch)) {
                throw new RuntimeException('Invalid embeddings payload received from sentence embeddings service.');
            }

            $ids = array_keys($batch);
            foreach ($embeddings as $index => $vector) {
                if (! is_array($vector)) {
                    throw new RuntimeException('Embedding vector is missing or malformed.');
                }

                $vectors[$ids[$index]] = array_map('floatval', $vector);
            }
        }

        return $vectors;
    }

    private function makeClient(): ?Client
    {
        $config = config('typesense');

        if (empty($config['api_key'])) {
            $this->error('TYPESENSE_API_KEY is not configured.');

            return null;
        }

        if (empty($config['nodes'])) {
            $this->error('Typesense nodes are not configured (see config/typesense.php).');

            return null;
        }

        return new Client([
            'api_key' => $config['api_key'],
            'nodes' => $config['nodes'],
            'connection_timeout_seconds' => Arr::get($config, 'connection_timeout_seconds', 2),
        ]);
    }

    private function collectionExists(Client $client, string $collectionName): bool
    {
        try {
            $client->collections[$collectionName]->retrieve();

            return true;
        } catch (ObjectNotFound) {
            return false;
        }
    }
}
